// Generated by CoffeeScript 1.8.0
(function() {
  var annotate, formats, name, placeholders, utils, _,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  _ = require('underscore');

  formats = require('./formats');

  placeholders = require('./placeholders');

  utils = require('./utils');

  annotate = function(match) {
    var lastChar;
    lastChar = match.match[match.match.length - 1];
    match.trailing = lastChar === '/' ? true : false;
    match.optional = _.contains(placeholders.optional, match.pattern);
    match.type = formats[match.type] || formats['*'];
    return match;
  };

  name = _.partial(utils.name, _, ['name', 'optional', 'type']);

  exports.InterpolationError = (function(_super) {
    __extends(InterpolationError, _super);

    InterpolationError.prototype.name = 'InterpolationError';

    function InterpolationError(message) {
      this.message = message;
      Error.captureStackTrace(this, this.constructor);
    }

    return InterpolationError;

  })(Error);

  exports.PathExp = (function() {
    function PathExp() {
      var raw, styles, type, _ref;
      raw = arguments[0], styles = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      this.raw = raw;
      this.styles = styles;
      type = typeof this.raw;
      if (type !== 'string') {
        throw new Error("Path expression should be a string. Instead got " + this.raw + " (" + type + ")");
      }
      if (!styles.length) {
        styles = ['unix', 'ruby', 'python'];
      }
      this.patterns = placeholders.get.apply(placeholders, styles);
      this.placeholders = this._analyze();
      this.hasPlaceholders = this.placeholders.length !== 0;
      _ref = this._findHead(), this.head = _ref[0], this.tail = _ref[1];
      this.regexp = this._compile();
    }

    PathExp.prototype._findHead = function() {
      var head, segment, tail, _i, _len, _ref;
      if (!this.hasPlaceholders) {
        return [this.raw, ''];
      }
      head = [];
      tail = [];
      _ref = this.raw.split('/');
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        segment = _ref[_i];
        if (tail.length || (utils.multimatch.apply(utils, [segment].concat(__slice.call(this.patterns)))).length) {
          tail.push(segment);
        } else {
          head.push(segment);
        }
      }
      return [head.join('/'), tail.join('/')];
    };

    PathExp.prototype._analyze = function() {
      var matches;
      matches = utils.multimatch.apply(utils, [this.raw].concat(__slice.call(this.patterns)));
      return matches.map(name).map(annotate);
    };

    PathExp.prototype._compile = function() {
      var expression, path, placeholder, replacement, type, _i, _len, _ref;
      path = this.raw.replace(/\((.+)\)/, '(?:$1)?', 'g');
      path = path.replace(/\./g, '\\.');
      _ref = this.placeholders;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        placeholder = _ref[_i];
        type = placeholder.type;
        if (placeholder.trailing) {
          replacement = "(?:(" + type + ")/?)";
        } else {
          replacement = "(" + type + ")";
        }
        if (placeholder.optional) {
          replacement += '?';
        }
        path = path.replace(placeholder.match, replacement);
      }
      expression = new RegExp("^" + path + "$");
      expression.placeholders = this.placeholders;
      return expression;
    };

    PathExp.prototype.match = function(str) {
      var matches, names;
      names = _.pluck(this.placeholders, 'name');
      matches = this.regexp.exec(str);
      if (matches === null) {
        return null;
      } else {
        return _.object(_.zip(names, matches.slice(1)));
      }
    };

    PathExp.prototype.replace = function(str, flags) {
      return this.regexp.replace(str, flags);
    };

    PathExp.prototype.fill = function(map) {
      var path, placeholder, replacement, _i, _len, _ref;
      path = this.raw;
      _ref = this.placeholders;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        placeholder = _ref[_i];
        replacement = map[placeholder.name];
        if (!replacement && placeholder.optional) {
          replacement = '';
        }
        if (replacement) {
          if (placeholder.trailing) {
            replacement += '/';
          }
        } else {
          if (placeholder.optional) {
            replacement = '';
          } else {
            throw new exports.InterpolationError("no value provided for `" + placeholder.name + "`");
          }
        }
        path = path.replace(placeholder.match, replacement);
      }
      return path.replace(/\((.+)\)/, '$1', 'g');
    };

    PathExp.prototype.toRegExp = function() {
      return this.regexp;
    };

    PathExp.prototype.toString = function() {
      return this.raw;
    };

    return PathExp;

  })();

}).call(this);
