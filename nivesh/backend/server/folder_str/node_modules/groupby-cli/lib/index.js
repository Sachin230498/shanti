// Generated by CoffeeScript 1.9.3
(function() {
  var InterpolationError, PathExp, UNCATEGORIZABLE, _, fill, groupsContainClashes, ref, slug, slugify;

  _ = require('underscore');

  slug = require('slug');

  ref = require('simple-path-expressions'), PathExp = ref.PathExp, InterpolationError = ref.InterpolationError;

  UNCATEGORIZABLE = '__uncategorizable__';

  slugify = function(value, lowercase) {
    var slugified;
    if (lowercase == null) {
      lowercase = false;
    }
    slugified = slug(value);
    if (lowercase) {
      return slugified.toLowerCase();
    } else {
      return slugified;
    }
  };

  fill = function(pattern, obj, options) {
    var err, slugifiedObj;
    slugifiedObj = _.object(_.compact(_.map(obj, function(value, key) {
      if (value == null) {
        return void 0;
      } else if (_.contains([Object, Array], value.constructor)) {
        return void 0;
      } else {
        return [key, slugify(value, options.lowercase)];
      }
    })));
    try {
      return pattern.fill(slugifiedObj);
    } catch (_error) {
      err = _error;
      if (options["catch"]) {
        if (typeof options["catch"] === 'string') {
          return options["catch"];
        } else {
          return UNCATEGORIZABLE;
        }
      } else {
        throw new Error(err.message + " for one or more objects. Consider using --catch.");
      }
    }
  };

  exports.enumerate = function(list, facets, options) {
    return _.object(_.map(facets, function(facet) {
      var keys, subIndex, values;
      values = _.pluck(list, facet);
      keys = _.map(values, function(value) {
        return slugify(value, options.lowercase);
      });
      subIndex = _.object(keys, values);
      return [facet, subIndex];
    }));
  };

  exports.group = function(list, grouper, options) {
    var facetList, groups, offenders, pattern, predicate;
    if (options == null) {
      options = {};
    }
    switch (grouper.constructor) {
      case String:
        pattern = new PathExp(grouper);
        break;
      case Array:
        facetList = grouper.map(function(facet) {
          return "<" + facet + ">";
        }).join(', ');
        pattern = new PathExp(facetList, 'unix');
        break;
      case Function:
        predicate = grouper;
        break;
      default:
        throw new Error("Grouper should be a pattern string, an array of facets or a grouping function. Instead got: " + grouper.constructor.name);
    }
    if (predicate == null) {
      predicate = _.partial(fill, pattern, _, options);
    }
    groups = _.groupBy(list, predicate);
    if (options.unique) {
      if (offenders = groupsContainClashes(groups)) {
        offenders = offenders.join('\n');
        throw new Error("Some groups contain more than one object: " + offenders + " Either disable the --unique option or specify a pattern string that produces unique groups.");
      }
      groups = _.object(_.map(groups, function(values, key) {
        return [key, values[0]];
      }));
    }
    return _.omit(groups, UNCATEGORIZABLE);
  };

  exports.groupsContainClashes = groupsContainClashes = function(groups) {
    return _.keys(_.pick(groups, function(group, key) {
      return group.length > 1;
    }));
  };

  exports.clashes = function(list, grouper, options) {
    var groups;
    groups = exports.group(list, grouper, options);
    return groupsContainClashes(groups);
  };

}).call(this);
